// automatically generated by Xtext
grammar fr.univcotedazur.l3ia.legolanguage.xtext.Uduv with org.eclipse.xtext.common.Terminals

import "http://www.example.org/langageCompilation" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Program returns Program:
	{Program}
		 
		(statement+=Statement)*
;

Statement returns Statement:
	If | Loop  | Variable | Print | Expression | Commentary | RobotDeclaration | Sensor | Actuator ;

RobotDeclaration returns Robot:
	'Robot' name=ID 
		('{'  
		"left" leftWheel = Wheel
		"right" rightWheel= Wheel 
		(actuator+=Actuator)*
		(sensor+=Sensor)*
		'}')?
;

/* to fix 
Module returns Module :
	Actuator | Sensor
;
 */

Expression returns Expression:
	 SensorProxy | ActuatorProxy | VariableProxy  | BinaryOperation;
	
Calcul returns Calcul : 
	Substarction | Addition | Division | Exponential | Multiplication ;
	
BinaryOperation returns BinaryOperation :
Comparaison |  Calcul |  Assignement /*| SensorOperation | ActuatorOperation*/ ;


Comparaison returns Comparaison:
	GT | LT | Equal | GTEqual | LTEqual ;

Variable returns Variable:
	LeInteger | LeString | LeFloat | LeBoolean;


Sensor returns Sensor : 
	ColorDector | Laser  
;

/*
ActuatorOperation returns ActuatorOperation :
	Robot = EString
	Go | Turn | ChangeAngle | ChangeIntensityLight | Shoot
;

SensorOperation returns SensorOperation :
	GetColor | GetDistance
;
*/
Actuator returns Actuator :
	Motor | Led
 
;	

Motor returns Motor :
	RotativeMotor | ShootLauncher
;

RotativeMotor returns RotativeMotor:
	Wheel | Arm
;

Commentary returns Commentary:
	{Commentary}
	'\'\'\''
		initialeValue=EString
		
	'\'\'\'';

Loop returns Loop : 
	WhileLoop | ForLoop  ; 

If returns If :
	'if'
	condition=Comparaison
	'{'
		(statement+=Statement)*
		
	'}';
	
WhileLoop returns WhileLoop:
	'while'

	 loopCondition=Comparaison
	'{'
		(statement+=Statement)*
		
	'}';

ForLoop returns ForLoop:
	'for'
	loopCondition=Comparaison
	'{'
		(statement+=Statement)*
		
	'}';

Addition returns Addition:
	'('
		left=Expression
		'+'
		right=Expression
	')';
	
Substarction returns Substarction:

	'('
		left=Expression
		'-'
		right=Expression
	')';
	
Division returns Division:

	'('
		left=Expression
		'/'
		right=Expression
	')';

Exponential returns Exponential:

	'('
		left=Expression
		'^'
		right=Expression
	')';

Multiplication returns Multiplication:

	'('
		left=Expression
		'*'
		right=Expression
	')';

GT returns GT:
	'('
		left=Expression
		'>'
		right=Expression
	')';
	
GTEqual returns GTEqual:
	'('
		left=Expression
		'>='
		right=Expression
	')';

LT returns LT:
	'('
		left=Expression
		'<'
		right=Expression
	')';

LTEqual returns LTEqual:
	'('
		left=Expression
		'<='
		right=Expression
	')';

Equal returns Equal:
	'('
		left=Expression
		'=='
		right=Expression
	')';
	
Assignement returns Assignement:
	
	'('
		left=Expression
		'='
		 right=Expression
	')'
	;

LeInteger returns LeInteger:
	{LeInteger}
	('int' name=EString '=')?
		initialeValue=EInt
		;

LeString returns LeString:
	{LeString}
	('string' name=EString '=')?
		initialeValue=EString
		;

LeBoolean returns LeBoolean:
	{LeBoolean}
	('boolean' name=EString '=')?
	
		 initialeValue=EBoolean
		;

LeFloat returns LeFloat:
	{LeFloat}
	('float' name=EString '=')?
		 initialeValue= EFloat 
		;

Print returns Print:
	{Print}
	'print' '(' (statement+=Statement)* ')'
	;

VariableProxy returns VariableProxy:
	variable=[Variable|EString]
	;

SensorProxy returns SensorProxy:
	sensor=[Sensor|EString]
	;

ActuatorProxy returns ActuatorProxy:
	actuator=[Actuator|EString]
	;
	
EBoolean returns ecore::EBoolean:
	'True' | 'False';
	
EString returns ecore::EString:
	STRING | ID;

EInt returns ecore::EInt:
	'-'? INT;

EFloat returns ecore::EFloat: 
	INT '.' INT
	;
	
Wheel returns Wheel : 
	{Wheel}
	'wheel' 
	'on'
	portID=EString
	("=" speed=EInt)?
;


Arm returns Arm : 
	{Arm}
	'arm'
	name=ID 
	'on'
	portID=EString
	("=" angle=EInt)?
; 


Led returns Led:
	{Led}
	'led'
	name=ID 
	'on'
	portID=EString
	("=" bright=EInt)?
;

 
ShootLauncher returns ShootLauncher : 
	{ShootLauncher}
	'shootLauncher'
	name=ID 
	'on'
	portID=EString
	("=" force=EInt)?
;


ColorDector returns ColorDector :
	{ColorDector}
	'colorDector'
	name=ID 
	'on'
	portID=EString
	
;	

Laser returns Laser :
	{Laser}
	'laser'
	name=ID 
	'on'
	portID=EString
	
;



/*
Turn returns Turn : 
	 
	'turn' '('
	direction=Direction
	(angle=EInt)?
	')'
;



*/