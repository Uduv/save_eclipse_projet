/*
 * generated by Xtext 2.25.0
 */
package fr.univcotedazur.l3ia.legolanguage.xtext.serializer;

import com.google.inject.Inject;
import fr.univcotedazur.l3ia.langagecompilation.Assignement;
import fr.univcotedazur.l3ia.langagecompilation.ForLoop;
import fr.univcotedazur.l3ia.langagecompilation.GT;
import fr.univcotedazur.l3ia.langagecompilation.LT;
import fr.univcotedazur.l3ia.langagecompilation.LegolanguagePrPackage;
import fr.univcotedazur.l3ia.langagecompilation.Print;
import fr.univcotedazur.l3ia.langagecompilation.Program;
import fr.univcotedazur.l3ia.langagecompilation.Substarction;
import fr.univcotedazur.l3ia.langagecompilation.Variable_Proxy;
import fr.univcotedazur.l3ia.langagecompilation.WhileLoop;
import fr.univcotedazur.l3ia.langagecompilation.leInteger;
import fr.univcotedazur.l3ia.langagecompilation.leString;
import fr.univcotedazur.l3ia.legolanguage.xtext.services.UduvGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class UduvSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UduvGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LegolanguagePrPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LegolanguagePrPackage.ASSIGNEMENT:
				sequence_Assignement(context, (Assignement) semanticObject); 
				return; 
			case LegolanguagePrPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case LegolanguagePrPackage.GT:
				sequence_GT(context, (GT) semanticObject); 
				return; 
			case LegolanguagePrPackage.LT:
				sequence_LT(context, (LT) semanticObject); 
				return; 
			case LegolanguagePrPackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case LegolanguagePrPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case LegolanguagePrPackage.SUBSTARCTION:
				sequence_Substarction(context, (Substarction) semanticObject); 
				return; 
			case LegolanguagePrPackage.VARIABLE_PROXY:
				sequence_Variable_Proxy(context, (Variable_Proxy) semanticObject); 
				return; 
			case LegolanguagePrPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			case LegolanguagePrPackage.LE_INTEGER:
				sequence_leInteger(context, (leInteger) semanticObject); 
				return; 
			case LegolanguagePrPackage.LE_STRING:
				sequence_leString(context, (leString) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns Assignement
	 *     Expression returns Assignement
	 *     Assignement returns Assignement
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Assignement(ISerializationContext context, Assignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignementAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignementAccess().getRightExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForLoop
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (loopCondition=Comparaison statement+=Statement*)
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GT
	 *     Comparaison returns GT
	 *     Expression returns GT
	 *     GT returns GT
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_GT(ISerializationContext context, GT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGTAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGTAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LT
	 *     Comparaison returns LT
	 *     Expression returns LT
	 *     LT returns LT
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_LT(ISerializationContext context, LT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLTAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLTAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Print
	 *     Expression returns Print
	 *     Print returns Print
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.STATEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (name=EString (statement+=Statement statement+=Statement*)?)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Substarction
	 *     Expression returns Substarction
	 *     Substarction returns Substarction
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Substarction(ISerializationContext context, Substarction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubstarctionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubstarctionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Variable_Proxy
	 *     Expression returns Variable_Proxy
	 *     Variable_Proxy returns Variable_Proxy
	 *
	 * Constraint:
	 *     (name=EString Variable=[Variable|EString])
	 */
	protected void sequence_Variable_Proxy(ISerializationContext context, Variable_Proxy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LegolanguagePrPackage.Literals.VARIABLE_PROXY__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LegolanguagePrPackage.Literals.VARIABLE_PROXY__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariable_ProxyAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariable_ProxyAccess().getVariableVariableEStringParserRuleCall_4_0_1(), semanticObject.eGet(LegolanguagePrPackage.Literals.VARIABLE_PROXY__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (loopCondition=Comparaison statement+=Statement*)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns leInteger
	 *     Variable returns leInteger
	 *     leInteger returns leInteger
	 *
	 * Constraint:
	 *     (isConst?='isConst'? name=EString initialeValue=EInt?)
	 */
	protected void sequence_leInteger(ISerializationContext context, leInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns leString
	 *     Variable returns leString
	 *     leString returns leString
	 *
	 * Constraint:
	 *     (name=EString initialeValue=EString?)
	 */
	protected void sequence_leString(ISerializationContext context, leString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
